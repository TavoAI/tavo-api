name: Release Management

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: "Release type"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
      force_version:
        description: "Force specific version (optional, overrides release_type)"
        required: false
        type: string
      packages:
        description: "Packages to release (comma-separated, empty for all)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  determine-version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      packages: ${{ steps.packages.outputs.packages }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: 20

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Determine packages to release
        id: packages
        run: |
          if [ -n "${{ github.event.inputs.packages }}" ]; then
            echo "packages=${{ github.event.inputs.packages }}" >> $GITHUB_OUTPUT
          else
            echo "packages=python,javascript,java,dotnet,rust,go" >> $GITHUB_OUTPUT
          fi

      - name: Determine version
        id: version
        run: |
          # Check if force version is specified
          if [ -n "${{ github.event.inputs.force_version }}" ]; then
            NEW_VERSION="${{ github.event.inputs.force_version }}"
            echo "Forced version: $NEW_VERSION"
          else
            # Find the highest valid semantic version tag
            LATEST_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -1 || echo "v0.0.0")
            LATEST_VERSION=${LATEST_TAG#v}

            echo "Latest valid tag: $LATEST_TAG"
            echo "Latest version: $LATEST_VERSION"

            # Determine release type
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
            if [ -z "$RELEASE_TYPE" ]; then
              RELEASE_TYPE="patch"
            fi

            # Calculate new version
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"

            case $RELEASE_TYPE in
              major)
                NEW_VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              patch)
                NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
              prerelease)
                NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))-alpha.$(date +%Y%m%d%H%M%S)"
                ;;
            esac
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $NEW_VERSION"

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: determine-version
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Create GitHub release
        id: create_release
        run: |
          if [[ "${{ needs.determine-version.outputs.version }}" == *alpha* ]]; then
            PRERELEASE_FLAG="--prerelease"
          else
            PRERELEASE_FLAG=""
          fi

          # Check if release already exists and delete it if it does
          if gh release view v${{ needs.determine-version.outputs.version }} >/dev/null 2>&1; then
            echo "Release v${{ needs.determine-version.outputs.version }} already exists. Deleting and recreating..."
            gh release delete v${{ needs.determine-version.outputs.version }} --yes
          fi

          echo "Creating release v${{ needs.determine-version.outputs.version }}..."
          gh release create v${{ needs.determine-version.outputs.version }} \
            --title "Release v${{ needs.determine-version.outputs.version }}" \
            --notes "## What's Changed

          Automated release v${{ needs.determine-version.outputs.version }}

          ### Packages Released
          ${{ needs.determine-version.outputs.packages }}

          ### Deployment
          - üì¶ Published to all configured registries
          - üìö Documentation updated
          - üè∑Ô∏è Version tags created" \
            --draft=false \
            $PRERELEASE_FLAG
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-python:
    name: Publish Python SDK
    needs: [determine-version, create-release]
    if: contains(needs.determine-version.outputs.packages, 'python')
    uses: ./.github/workflows/publish-python.yml
    with:
      version: ${{ needs.determine-version.outputs.version }}
    secrets: inherit

  publish-javascript:
    name: Publish JavaScript SDK
    needs: [determine-version, create-release]
    if: contains(needs.determine-version.outputs.packages, 'javascript')
    uses: ./.github/workflows/publish-javascript.yml
    with:
      version: ${{ needs.determine-version.outputs.version }}
    secrets: inherit

  publish-java:
    name: Publish Java SDK
    needs: [determine-version, create-release]
    if: contains(needs.determine-version.outputs.packages, 'java')
    uses: ./.github/workflows/publish-java.yml
    with:
      version: ${{ needs.determine-version.outputs.version }}
    secrets: inherit

  publish-dotnet:
    name: Publish .NET SDK
    needs: [determine-version, create-release]
    if: contains(needs.determine-version.outputs.packages, 'dotnet')
    uses: ./.github/workflows/publish-dotnet.yml
    with:
      version: ${{ needs.determine-version.outputs.version }}
    secrets: inherit

  publish-rust:
    name: Publish Rust SDK
    needs: [determine-version, create-release]
    if: contains(needs.determine-version.outputs.packages, 'rust')
    uses: ./.github/workflows/publish-rust.yml
    with:
      version: ${{ needs.determine-version.outputs.version }}
    secrets: inherit

  publish-go:
    name: Publish Go SDK
    needs: [determine-version, create-release]
    if: contains(needs.determine-version.outputs.packages, 'go')
    uses: TavoAI/tavo-go-sdk/.github/workflows/publish-go.yml@main
    with:
      version: ${{ needs.determine-version.outputs.version }}
    secrets: inherit

  update-changelog:
    name: Update Changelog
    runs-on: ubuntu-latest
    needs:
      [
        determine-version,
        publish-python,
        publish-javascript,
        publish-java,
        publish-dotnet,
        publish-rust,
        publish-go,
      ]

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: 20

      - name: Generate changelog
        run: |
          # Generate changelog entry
          echo "# Changelog" > CHANGELOG.md.tmp
          echo "" >> CHANGELOG.md.tmp
          echo "## [v${{ needs.determine-version.outputs.version }}] - $(date +%Y-%m-%d)" >> CHANGELOG.md.tmp
          echo "" >> CHANGELOG.md.tmp
          echo "### Added" >> CHANGELOG.md.tmp
          echo "- Automated publishing pipelines for all SDKs" >> CHANGELOG.md.tmp
          echo "" >> CHANGELOG.md.tmp
          echo "### Changed" >> CHANGELOG.md.tmp
          echo "- Improved CI/CD workflows" >> CHANGELOG.md.tmp
          echo "" >> CHANGELOG.md.tmp
          echo "### Fixed" >> CHANGELOG.md.tmp
          echo "- Various bug fixes and improvements" >> CHANGELOG.md.tmp
          echo "" >> CHANGELOG.md.tmp

          # Prepend to existing changelog if it exists
          if [ -f CHANGELOG.md ]; then
            cat CHANGELOG.md >> CHANGELOG.md.tmp
          fi

          mv CHANGELOG.md.tmp CHANGELOG.md

      - name: Commit changelog
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          git commit -m "docs: update changelog for v${{ needs.determine-version.outputs.version }}" || true
          git push

  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs:
      [
        determine-version,
        publish-python,
        publish-javascript,
        publish-java,
        publish-dotnet,
        publish-rust,
        publish-go,
        update-changelog,
      ]
    if: always()

    steps:
      - name: Notify success
        if: (needs.publish-python.result == 'success' || needs.publish-python.result == 'skipped') && (needs.publish-javascript.result == 'success' || needs.publish-javascript.result == 'skipped') && (needs.publish-java.result == 'success' || needs.publish-java.result == 'skipped') && (needs.publish-dotnet.result == 'success' || needs.publish-dotnet.result == 'skipped') && (needs.publish-rust.result == 'success' || needs.publish-rust.result == 'skipped') && (needs.publish-go.result == 'success' || needs.publish-go.result == 'skipped')
        run: |
          echo "üéâ All packages published successfully!"
          echo "Version: v${{ needs.determine-version.outputs.version }}"

      - name: Notify partial failure
        if: needs.publish-python.result == 'failure' || needs.publish-javascript.result == 'failure' || needs.publish-java.result == 'failure' || needs.publish-dotnet.result == 'failure' || needs.publish-rust.result == 'failure' || needs.publish-go.result == 'failure'
        run: |
          echo "‚ö†Ô∏è Some packages failed to publish. Check the logs above."
          echo "Version: v${{ needs.determine-version.outputs.version }}"
